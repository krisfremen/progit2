[[_remote_branches]]
=== Далечински гранки

(((branches, remote)))(((references, remote)))
Далечните референции се референци (покажувачи) во оддалечените репозиториуми, вклучувајќи ги гранките, таговите и така натаму.
Можете да добиете целосна листа на далечински референци експлицитно со `git ls-remote [remote]` `или` git remote show [remote] `за далечински гранки, како и повеќе информации.
Сепак, почесто е да ги искористиме гранките за следење на далечина.

Ограноци за следење на далечина се референци за состојбата на оддалечените гранки.
Тие се локални референци кои не можете да ги преместите; Git ги придвижува за вас секогаш кога ќе направите некоја мрежна комуникација, за да бидете сигурни дека тие точно ја претставуваат состојбата на далечинското складиште.
Помислете ги како обележувачи, за да ве потсетам каде што филијалите во оддалечените складишта беа последниот пат кога сте се поврзавте со нив.

Гранките за следење на далечина се во формата `<далечински> / <филијала>`.
На пример, ако сакавте да видам што "господар" филијала на вашиот "потекло" далечински изгледаше како последен пат кога сте го комуницирале со тоа, ќе ја проверите гранката "потекло / господар".
Доколку работевте на некое прашање со партнер и тие го натераа грантот `iss53`, може да имате своја сопствена локална` iss53` филијала, но филијалата на серверот ќе биде претставена од филијалата за далечинско следење `потекло / iss53 `.

Ова може да биде малку збунувачки, па ајде да погледнеме пример.
Да речеме дека имаш Git сервер во твојата мрежа на `git.ourcompany.com`.
Ако клонирате од ова, командата `клон` на Git автоматски го именува` потекло` за вас, ги симнува сите свои податоци, создава покажувач до тоа каде е нејзината `господарна гранка` и именува тоа` потекло / господар` локално.
Git, исто така, ви дава своја локална `мастер` филијала која започнува на истото место како гранка на" мајсторот "на потеклото, така што од вас има нешто да се работи.

[ЗАБЕЛЕШКА]
.``origin'' не е посебен
====
Исто како што името на гранката ``master'' нема посебно значење во Git, ниту "origin".
Додека ``master'' е стандардното име за почетна гранка кога ќе стартувате `git init`, што е единствената причина што е широко користен,` `origin'' е стандардното име за далечинскиот управувач кога извршувате `git clone`.
Ако извршите `git clone -o booyah` наместо, тогаш ќе имате `booyah/master` како вашата стандардна далечинска гранка.(((origin)))
====

.Server and local repositories after cloning
image::images/remote-branches-1.png[Server and local repositories after cloning.]

Ако направите некоја работа на вашата локална `господар` гранка, а во меѓувреме некој друг турка до` git.ourcompany.com` и ја ажурира својата `master` гранка, тогаш вашите истории се движат напред поинаку.
Исто така, додека не сте во контакт со вашиот потекло сервер, вашиот "origin/master" покажувач не се движи.

.Local and remote work can diverge
image::images/remote-branches-2.png[Local and remote work can diverge.]

За да ја синхронизирате вашата работа, извршувате команда `git fetch origin`.
Оваа команда се осврнува на кој "потекло" на серверот е (во овој случај, тоа е `git.ourcompany.com`), добива какви било податоци од него, кои сеуште не ги имате, и ја ажурира вашата локална база на податоци, преместувајќи го вашето `origin/master` покажувач на неговата нова, посовремена позиција.

.`git fetch` updates your remote references
image::images/remote-branches-3.png[`git fetch` updates your remote references.]


За да покажете дека имате повеќе далечински сервери и што изгледаат оддалечените филијали за тие оддалечени проекти, да претпоставиме дека имате друг внатрешен Git сервер кој се користи само за развој од еден од вашите спринтови тимови.
Овој сервер е на `git.team1.ourcompany.com`.
Можете да го додадете како нова оддалечена референца за проектот во којшто моментално работите со извршување на командата `git remote add`, како што се опфатени во глава <<ch02-git-basics-chapter#ch02-git-basics-chapter>>.
Наведете го ова далечинско "teamone", кое ќе биде вашето кратко име за целата УРЛ-адреса.

.Adding another server as a remote
image::images/remote-branches-4.png[Adding another server as a remote.]

Сега, можете да го стартувате `git fetch teamone` за да донесат сè што далечинскиот сервер` teamone` го има што уште немате.
Бидејќи тој сервер има подмножество на податоците што ги има серверот "origin" сега, Git не добива никакви податоци, туку поставува филијала за следење на далечина наречена `teamone / master` за да укаже на извршувањето кое` teamone` го има како `master` гранка.
.Remote tracking branch for `teamone/master`
image::images/remote-branches-5.png[Remote tracking branch for `teamone/master`.]

[[_pushing_branches]]
==== Pushing

(((pushing)))
Кога сакате да споделите гранка со светот, треба да го притиснете на далечинскиот управувач до кој имате пристап за запишување.
Вашите локални гранки не се автоматски синхронизирани со дистанционерите што ги пишувате - мора експлицитно да ги притиснете гранките што сакате да ги споделите.
На тој начин можете да користите приватни ограноци за работа што не сакате да ги споделите и да ги зголемите само гранките на тема што сакате да соработувате.

Ако имате филијала наречена `serverfix` со која сакате да работите со други, можете да го притиснете на истиот начин како што ја турнавте вашата прва гранка.
Извршите `git push <remote> <branch>`:(((git commands, push)))

[source,console]
----
$ git push origin serverfix
Counting objects: 24, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (15/15), done.
Writing objects: 100% (24/24), 1.91 KiB | 0 bytes/s, done.
Total 24 (delta 2), reused 0 (delta 0)
To https://github.com/schacon/simplegit
 * [new branch]      serverfix -> serverfix
----

This is a bit of a shortcut.
Git automatically expands the `serverfix` branchname out to `refs/heads/serverfix:refs/heads/serverfix`, which means, ``Take my serverfix local branch and push it to update the remote's serverfix branch.''
We'll go over the `refs/heads/` part in detail in <<ch10-git-internals#ch10-git-internals>>, but you can generally leave it off.
You can also do `git push origin serverfix:serverfix`, which does the same thing -- it says, ``Take my serverfix and make it the remote's serverfix.''
You can use this format to push a local branch into a remote branch that is named differently.
If you didn't want it to be called `serverfix` on the remote, you could instead run `git push origin serverfix:awesomebranch` to push your local `serverfix` branch to the `awesomebranch` branch on the remote project.

[NOTE]
.Don't type your password every time
====
If you're using an HTTPS URL to push over, the Git server will ask you for your username and password for authentication.
By default it will prompt you on the terminal for this information so the server can tell if you're allowed to push.

If you don't want to type it every single time you push, you can set up a ``credential cache''.
The simplest is just to keep it in memory for a few minutes, which you can easily set up by running `git config --global credential.helper cache`.

For more information on the various credential caching options available, see <<ch07-git-tools#_credential_caching>>.
====

The next time one of your collaborators fetches from the server, they will get a reference to where the server's version of `serverfix` is under the remote branch `origin/serverfix`:

[source,console]
----
$ git fetch origin
remote: Counting objects: 7, done.
remote: Compressing objects: 100% (2/2), done.
remote: Total 3 (delta 0), reused 3 (delta 0)
Unpacking objects: 100% (3/3), done.
From https://github.com/schacon/simplegit
 * [new branch]      serverfix    -> origin/serverfix
----

It's important to note that when you do a fetch that brings down new remote-tracking branches, you don't automatically have local, editable copies of them.
In other words, in this case, you don't have a new `serverfix` branch -- you only have an `origin/serverfix` pointer that you can't modify.

To merge this work into your current working branch, you can run `git merge origin/serverfix`.
If you want your own `serverfix` branch that you can work on, you can base it off your remote-tracking branch:

[source,console]
----
$ git checkout -b serverfix origin/serverfix
Branch serverfix set up to track remote branch serverfix from origin.
Switched to a new branch 'serverfix'
----

This gives you a local branch that you can work on that starts where `origin/serverfix` is.

[[_tracking_branches]]
==== Tracking Branches

(((branches, tracking)))(((branches, upstream)))
Checking out a local branch from a remote-tracking branch automatically creates what is called a ``tracking branch'' (and the branch it tracks is called an ``upstream branch'').
Tracking branches are local branches that have a direct relationship to a remote branch.
If you're on a tracking branch and type `git pull`, Git automatically knows which server to fetch from and which branch to merge in.

When you clone a repository, it generally automatically creates a `master` branch that tracks `origin/master`.
However, you can set up other tracking branches if you wish -- ones that track branches on other remotes, or don't track the `master` branch.
The simple case is the example you just saw, running `git checkout -b <branch> <remote>/<branch>`.
This is a common enough operation that Git provides the `--track` shorthand:

[source,console]
----
$ git checkout --track origin/serverfix
Branch serverfix set up to track remote branch serverfix from origin.
Switched to a new branch 'serverfix'
----

In fact, this is so common that there's even a shortcut for that shortcut. If the branch name you're trying to checkout (a) doesn't exist and (b) exactly matches a name on only one remote, Git will create a tracking branch for you:

[source,console]
----
$ git checkout serverfix
Branch serverfix set up to track remote branch serverfix from origin.
Switched to a new branch 'serverfix'
----

To set up a local branch with a different name than the remote branch, you can easily use the first version with a different local branch name:

[source,console]
----
$ git checkout -b sf origin/serverfix
Branch sf set up to track remote branch serverfix from origin.
Switched to a new branch 'sf'
----

Now, your local branch `sf` will automatically pull from `origin/serverfix`.

If you already have a local branch and want to set it to a remote branch you just pulled down, or want to change the upstream branch you're tracking, you can use the `-u` or `--set-upstream-to` option to `git branch` to explicitly set it at any time.

[source,console]
----
$ git branch -u origin/serverfix
Branch serverfix set up to track remote branch serverfix from origin.
----

[NOTE]
.Upstream shorthand
====
When you have a tracking branch set up, you can reference its upstream branch with the `@{upstream}` or `@{u}` shorthand.
So if you're on the `master` branch and it's tracking `origin/master`, you can say something like `git merge @{u}` instead of `git merge origin/master` if you wish.(((+++@{u}+++)))(((+++@{upstream}+++)))
====

If you want to see what tracking branches you have set up, you can use the `-vv` option to `git branch`.
This will list out your local branches with more information including what each branch is tracking and if your local branch is ahead, behind or both.

[source,console]
----
$ git branch -vv
  iss53     7e424c3 [origin/iss53: ahead 2] forgot the brackets
  master    1ae2a45 [origin/master] deploying index fix
* serverfix f8674d9 [teamone/server-fix-good: ahead 3, behind 1] this should do it
  testing   5ea463a trying something new
----

So here we can see that our `iss53` branch is tracking `origin/iss53` and is ``ahead'' by two, meaning that we have two commits locally that are not pushed to the server.
We can also see that our `master` branch is tracking `origin/master` and is up to date.
Next we can see that our `serverfix` branch is tracking the `server-fix-good` branch on our `teamone` server and is ahead by three and behind by one, meaning that there is one commit on the server we haven't merged in yet and three commits locally that we haven't pushed.
Finally we can see that our `testing` branch is not tracking any remote branch.

It's important to note that these numbers are only since the last time you fetched from each server.
This command does not reach out to the servers, it's telling you about what it has cached from these servers locally.
If you want totally up to date ahead and behind numbers, you'll need to fetch from all your remotes right before running this.
You could do that like this:

[source,console]
----
$ git fetch --all; git branch -vv
----

==== Pulling

(((pulling)))
While the `git fetch` command will fetch down all the changes on the server that you don't have yet, it will not modify your working directory at all.
It will simply get the data for you and let you merge it yourself.
However, there is a command called `git pull` which is essentially a `git fetch` immediately followed by a `git merge` in most cases.
If you have a tracking branch set up as demonstrated in the last section, either by explicitly setting it or by having it created for you by the `clone` or `checkout` commands, `git pull` will look up what server and branch your current branch is tracking, fetch from that server and then try to merge in that remote branch.

Generally it's better to simply use the `fetch` and `merge` commands explicitly as the magic of `git pull` can often be confusing.

[[_delete_branches]]
==== Deleting Remote Branches

(((branches, deleting remote)))
Suppose you're done with a remote branch – say you and your collaborators are finished with a feature and have merged it into your remote's `master` branch (or whatever branch your stable codeline is in).
You can delete a remote branch using the `--delete` option to `git push`.
If you want to delete your `serverfix` branch from the server, you run the following:

[source,console]
----
$ git push origin --delete serverfix
To https://github.com/schacon/simplegit
 - [deleted]         serverfix
----

Basically all this does is remove the pointer from the server.
The Git server will generally keep the data there for a while until a garbage collection runs, so if it was accidentally deleted, it's often easy to recover.
