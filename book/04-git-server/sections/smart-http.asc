=== Smart HTTP

(((serving repositories, HTTP)))
Сега имаме автентичен пристап преку SSH и пристап без пристап преку `git: //`, но исто така постои и протокол кој може да го стори истовремено.
Поставувањето на Smart HTTP е во основа едноставно овозможување CGI скрипта која е обезбедена со Git наречен `git-http-backend` на серверот. (((Git команди," http-backend ")))
Овој CGI ќе ја прочита патеката и заглавјата испратени од `git fetch` или` git push` до HTTP URL и утврди дали клиентот може да комуницира преку HTTP (што е точно за секој клиент од верзија 1.6.6).
Ако CGI гледа дека клиентот е паметен, тој ќе комуницира умно со него; инаку ќе се врати на глувото однесување (па затоа е назад компатибилен за читања со постари клиенти).

Ајде да одиме низ многу основни поставувања.
Ние ќе го поставите ова со Apache како сервер CGI.
Ако немате Apache-то подесување, можете да го направите тоа во полето за Линукс со нешто слично:(((Apache)))

[source,console]
----
$ sudo apt-get install apache2 apache2-utils
$ a2enmod cgi alias env
----

Ова, исто така, им овозможува на модулите `mod_cgi`,` mod_alias` и `mod_env`, кои се потребни за правилно функционирање.

Исто така, ќе треба да ја наместите Unix корисничката група на директориуми `/ srv / git` на` www-data`, така што вашиот веб-сервер може да ги чита и да ги запише-пристап до складиштата, бидејќи примерот на Apache кој ја извршува скриптата CGI ќе стандардно) да се работи како тој корисник:

[source,console]
----
$ chgrp -R www-data /srv/git
----

Следно ние треба да додадеме некои работи во конфигурацијата на Apache за да го стартувате `git-http-backend` како управувач за нешто што доаѓа во патеката` / git` на вашиот веб сервер.

[source,console]
----
SetEnv GIT_PROJECT_ROOT /srv/git
SetEnv GIT_HTTP_EXPORT_ALL
ScriptAlias /git/ /usr/lib/git-core/git-http-backend/
----

Ако ја оставите `GIT_HTTP_EXPORT_ALL` променливата на околината, тогаш Git само ќе им служи на клиентите кои не ги идентификуваат клиентите со складиштето` git-daemon-export-ok` во нив, исто како што го правеше демонот Git.

Конечно, ќе сакате да му кажете на Apache да им дозволи на барањата на `git-http-backend` и да направат писма да бидат автентицирани некако, можеби со блок Auth, како што е:

[source,console]
----
<Files "git-http-backend">
    AuthType Basic
    AuthName "Git Access"
    AuthUserFile /srv/git/.htpasswd
    Require expr !(%{QUERY_STRING} -strmatch '*service=git-receive-pack*' || %{REQUEST_URI} =~ m#/git-receive-pack$#)
    Require valid-user
</Files>
----

Тоа ќе бара од вас да креирате датотека .htpasswd која ги содржи лозинките на сите валидни корисници.
Еве еден пример за додавање на `` schacon '' корисник во датотеката:

[source,console]
----
$ htpasswd -c /srv/git/.htpasswd schacon
----

Постојат тони начини да имате Apache-то автентикација на корисниците, ќе мора да изберете и да имплементирате еден од нив.
Ова е само наједноставниот пример со кој би можеле да излеземе.
Исто така, речиси сигурно сакате да го поставите ова преку SSL, па сите овие податоци се шифрираат.

Ние не сакаме да одиме премногу далеку по зајакот дупка на Apache специфики за конфигурација, бидејќи вие би можеле да користите друг сервер или да имаат различни потреби за автентикација.
Идејата е дека Git доаѓа со CGI наречен `git-http-backend`, кој кога ќе се повика, ќе ги направи сите преговори да испраќаат и примаат податоци преку HTTP.
Таа не имплементира ниедна проверка на автентичност, но таа лесно може да се контролира на слојот на веб серверот кој се повикува.
Можете да го направите ова со скоро секој веб-сервер способен за CGI, па затоа одете со оној што го знаете најдобро.

[NOTE]
====
За повеќе информации за конфигурирање автентикација во Apache, проверете ги документите на Apache тука: http://httpd.apache.org/docs/current/howto/auth.html []
====
